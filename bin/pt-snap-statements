#!/usr/bin/env python
# coding: UTF-8

# pt-snap-statements
#
# Copyright(c) 2015 Uptime Technologies, LLC.

import sys, os, re
libpath = os.path.abspath(os.path.dirname(sys.argv[0]) + "/../lib")
sys.path.append(libpath)

import getopt
import PsqlWrapper
import log

class SnapStatements:

    def __init__(self, psql, interval, n_top, debug=False):
        self.debug = debug

        self.psql = psql

        # Max queries to be listed.
        if n_top is None:
            n_top = 10000

        log.debug("version: %s", self.psql.get_version())

        self.query = self._build_query_string(interval, n_top)

    def _build_query_string(self, interval, n_top):
        sql = r'''
/*SNAP*/ CREATE TEMP TABLE snap_pg_stat_statements
    AS SELECT userid,
              dbid,
              queryid,                               -- #if 9.4
              query,
              sum(calls) AS calls,
              sum(total_time) AS total_time,
              sum(rows) AS rows,
              sum(shared_blks_hit) + sum(local_blks_hit) AS blks_hit,
              sum(shared_blks_read) + sum(local_blks_read) + sum(temp_blks_read) AS blks_read,
              sum(shared_blks_dirtied) + sum(local_blks_dirtied) AS blks_dirtied,  -- #if 9.2
              sum(shared_blks_written) + sum(local_blks_written) + sum(temp_blks_written) AS blks_written
            , sum(blk_read_time) AS blk_read_time    -- #if 9.2
            , sum(blk_write_time) AS blk_write_time  -- #if 9.2
         FROM pg_stat_statements
        GROUP BY userid,
                 dbid,
                 queryid,                            -- #if 9.4
                 query;

/*SNAP*/ SELECT pg_sleep({interval});

/*SNAP*/ CREATE TEMP TABLE snap_pg_stat_statements2
    AS SELECT userid,
              dbid,
              queryid,                               -- #if 9.4
              query,
              sum(calls) AS calls,
              sum(total_time) AS total_time,
              sum(rows) AS rows,
              sum(shared_blks_hit) + sum(local_blks_hit) AS blks_hit,
              sum(shared_blks_read) + sum(local_blks_read) + sum(temp_blks_read) AS blks_read,
              sum(shared_blks_dirtied) + sum(local_blks_dirtied) AS blks_dirtied, -- #if 9.2
              sum(shared_blks_written) + sum(local_blks_written) + sum(temp_blks_written) AS blks_written
            , sum(blk_read_time) AS blk_read_time    -- #if 9.2
            , sum(blk_write_time) AS blk_write_time  -- #if 9.2
         FROM pg_stat_statements
        GROUP BY userid,
                 dbid,
                 queryid,                            -- #if 9.4
                 query;

SELECT u.usename AS "USER",
       d.datname AS "DBNAME",
       to_hex(s1.queryid) AS "QUERYID",              -- #if 9.4
       substring(s1.query, 1, 30) AS "QUERY",
       ( s1.calls - coalesce(s2.calls,0) ) AS "CALLS",
       ( s1.total_time - coalesce(s2.total_time,0) )::integer AS "T_TIME",
       ( s1.rows - coalesce(s2.rows,0) ) AS "ROWS",
       ( s1.blks_hit - coalesce(s2.blks_hit,0) ) AS "B_HIT",
       ( s1.blks_read - coalesce(s2.blks_read,0) ) AS "B_READ",
       ( s1.blks_dirtied - coalesce(s2.blks_dirtied,0) ) AS "B_DIRT",   -- #if 9.2
       ( s1.blks_written - coalesce(s2.blks_written,0) ) AS "B_WRTN"
     , round( (s1.blk_read_time - coalesce(s2.blk_read_time,0))::numeric, 1) AS "R_TIME"    -- #if 9.2
     , round( (s1.blk_write_time - coalesce(s2.blk_write_time,0))::numeric, 1) AS "W_TIME"  -- #if 9.2
  FROM snap_pg_stat_statements2 AS s1
       LEFT OUTER JOIN snap_pg_stat_statements s2 ON s1.userid = s2.userid
           AND s1.dbid = s2.dbid
           AND s1.query = s2.query
       LEFT OUTER JOIN pg_database d ON s1.dbid = d.oid
       LEFT OUTER JOIN pg_user u ON s1.userid = u.usesysid
 WHERE ( s1.calls - coalesce(s2.calls,0) ) > 0
   AND s1.query NOT LIKE '--%'
   AND s1.query NOT LIKE '/*SNAP*/ %'
 ORDER BY 6 DESC
 LIMIT {n_top};
'''[1:].format(interval=interval, n_top=n_top)
        sql = self._modify_query_string(sql, self.psql.get_version())
        return sql

    def _modify_query_string(self, sql, pg_ver):
        if pg_ver < 9.4:
            sql = re.sub(r'(.*-- #if 9\.4\n)', r'--\1', sql)
        if pg_ver < 9.2:
            sql = re.sub(r'(.*-- #if 9\.2\n)', r'--\1', sql)
        return sql

    def check(self):
        query = r'''
select count(*) as "pg_stat_statements"
  from pg_class c left outer join pg_namespace n
         on c.relnamespace = n.oid
 where n.nspname='public'
   and c.relname='pg_stat_statements'
'''[1:]

        rs = self.psql.execute_query(query)
        log.debug("check: %r", rs)

        if int(rs[1][0]) != 1:
            log.error("pg_stat_statements view not found.")
            return False

        query = r'''
select count(*) as "track_io_timing"
  from pg_settings
 where name = 'track_io_timing'
   and setting = 'on'
'''[1:]

        rs = self.psql.execute_query(query)
        log.debug("check: %r", rs)

        if self.psql.get_version() >= 9.2 and int(rs[1][0]) != 1:
            log.warning("track_io_timing is diabled.")

        return True

    def reset(self):
        query = 'SELECT pg_stat_statements_reset();'

        rs = self.psql.execute_query(query)
        log.debug("reset: %r", rs)

        if len(rs) == 0 or rs[0][0] != 'pg_stat_statements_reset':
            log.error("Cannot reset.")
            log.error("Check your privilege and database.")

        return True

    def get(self):
     	if self.check() is False:
            return False

        log.debug("get: %s", self.query)

        rs = self.psql.execute_query(self.query)

        avail = False
        rs2 = []
        for r in rs:
            if r[0] == 'USER':
                avail = True
            if avail is True:
                rs2.append(r)

        log.debug("get: %r", rs2)

        self.psql.print_result(rs2)

        return True

def usage():
    command = os.path.basename(sys.argv[0])
    usage = USAGE.format(command=command)
    return usage

USAGE = r'''
Usage: {command} [option...] [interval]
Options:
    -h, --host=HOSTNAME        Host name of the postgres server
    -p, --port=PORT            Port number of the postgres server
    -U, --username=USERNAME    User name to connect
    -d, --dbname=DBNAME        Database name to connect

    -t, --top=NUMBER           Number of queries to be listed
    -R, --reset                Reset statistics

    --help                     Print this help.
'''


class CommandOptions(object):

    def __init__(self, host, port, username, dbname, n_top, do_reset, help, debug):
        self.host     = host
        self.port     = port
        self.username = username
        self.dbname   = dbname
        self.n_top    = n_top
        self.do_reset = do_reset
        self.help     = help
        self.debug    = debug


def parse_command_options(args):
    opts, args = getopt.getopt(args, "h:p:U:d:Rt:",
                               ["help", "debug", "host=", "port=", "username=", "dbname=",
                                "reset", "top="])
    host     = None
    port     = None
    username = None
    dbname   = None
    n_top    = None

    do_reset = False
    help     = False
    debug    = None

    for o, a in opts:
        if o in ("-h", "--host"):
            host = a
        elif o in ("-p", "--port"):
            port = int(a)
        elif o in ("-U", "--username"):
            username = a
        elif o in ("-d", "--dbname"):
            dbname = a
        elif o in ("-R", "--reset"):
            do_reset = True
        elif o in ("-t", "--top"):
            n_top = int(a)
        elif o in ("--debug"):
            debug = True
        elif o in ("--help"):
            help = True
        else:
            raise getopt.GetoptError("unknown option: %s, %s" % (o, a))

    opts = CommandOptions(host, port, username, dbname, n_top, do_reset, help, debug)
    return opts, args


def main():
    try:
        opts, args = parse_command_options(sys.argv[1:])
        try:
            interval = int(args[0]) if args else None
        except ValueError as err:
            raise getopt.GetoptError("%s: integer expected." % (args[0],))
    except getopt.GetoptError as err:
        log.error('%s', err)
        print(usage())
        return 2

    x = opts
    (  host,   port,   username,   dbname,   n_top,   do_reset,   help,   debug ) = \
    (x.host, x.port, x.username, x.dbname, x.n_top, x.do_reset, x.help, x.debug )

    if help:
        print(usage())
        return 0
    if debug:
        log.setLevel(log.DEBUG)

    p = PsqlWrapper.PsqlWrapper(host=host, port=port, username=username, dbname=dbname, on_error_stop=True, debug=debug)

    if do_reset is True:
        log.info("Resetting statistics.")
        snap = SnapStatements(p, 0, 0, debug=debug)
        snap.reset()
        return 0

    if interval is None:
        log.info("Interval is 10 seconds.")
        interval = 10

    snap = SnapStatements(p, interval, n_top, debug=debug)
    try:
        ok = snap.get()
    except KeyboardInterrupt:
        log.info("Terminated.")
        return 1
    else:
        if not ok:
            return 1

    return 0


if __name__ == "__main__":
    status = main()
    sys.exit(status)
